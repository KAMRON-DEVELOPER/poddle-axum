logging {
	level  = "info"
	format = "logfmt"
}

// ---------------------------------------------------------
// LOGS COLLECTION
// ---------------------------------------------------------

discovery.kubernetes "pods" {
	role = "pod"

	selectors {
		role  = "pod"
		field = "spec.nodeName=" + coalesce(env("HOSTNAME"), constants.hostname)
	}
}

discovery.relabel "pod_logs" {
	targets = discovery.kubernetes.pods.targets

	// rule {
	// 	source_labels = ["__meta_kubernetes_pod_node_name"]
	// 	target_label  = "__host__"
	// }

	// rule {
	// 	source_labels = ["__host__"]
	// 	regex         = env("HOSTNAME")
	// 	action        = "keep"
	// }

	// Construct the path to the log file on the host
	// Path format: /var/log/pods/<namespace>_<pod_name>_<uid>/<container_name>/*.log
	rule {
		source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
		target_label  = "__path__"
		separator     = "/"
		replacement   = "/var/log/pods/*_*_$3/$4/*.log"
	}

	// Standard Labels
	rule {
		source_labels = ["__meta_kubernetes_namespace"]
		target_label  = "namespace"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_name"]
		target_label  = "pod"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_container_name"]
		target_label  = "container"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_label_app"]
		target_label  = "app"
	}

	// Custom Labels
	rule {
		source_labels = ["__meta_kubernetes_pod_label_project_id"]
		target_label  = "project_id"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_label_deployment_id"]
		target_label  = "deployment_id"
	}

	rule {
		source_labels = ["__meta_kubernetes_pod_label_managed_by"]
		target_label  = "managed_by"
	}
}

// Read the files directly from disk (Efficient!)
loki.source.file "pods" {
	targets    = discovery.relabel.pod_logs.output
	forward_to = [loki.process.default.receiver]
}

loki.process "default" {
	forward_to = [loki.write.default.receiver]

	// Tag everything as containerd (since Poddle is on K3s/Cilium)
	stage.static_labels {
		values = {
			tmp_container_runtime = "containerd",
		}
	}

	stage.json {
		expressions = {
			level    = "level",
			trace_id = "trace_id",
			msg      = "message",
			time     = "timestamp",
		}
	}

	// Promotes level from extracted field â†’ Loki label
	// You can filter {level="error"} in Loki, Improves query ergonomics
	stage.labels {
		values = {
			level    = "level",
			trace_id = "trace_id",
		}
	}

	stage.match {
		selector = "{tmp_container_runtime=\"containerd\"}"

		stage.cri { }

		stage.labels {
			values = {
				flags  = "",
				stream = "",
			}
		}
	}

	stage.match {
		selector = "{tmp_container_runtime=\"docker\"}"

		stage.docker { }

		stage.labels {
			values = {
				stream = "",
			}
		}
	}

	// Cleanup temporary labels
	stage.label_drop {
		values = ["tmp_container_runtime"]
	}
}

loki.write "default" {
	endpoint {
		url = "http://loki.loki.svc.cluster.local:3100/loki/api/v1/push"
	}
}

// ---------------------------------------------------------
// CONTAINER METRICS (via kubelet's built-in cAdvisor)
// ---------------------------------------------------------

// Discover all nodes in the cluster
discovery.kubernetes "nodes" {
	role = "node"
}

// Relabel to construct kubelet metrics endpoint
discovery.relabel "cadvisor" {
	targets = discovery.kubernetes.nodes.targets

	// Keep only the current node
	rule {
		source_labels = ["__meta_kubernetes_node_name"]
		regex         = env("HOSTNAME")
		action        = "keep"
	}

	// Use the node's internal IP
	rule {
		source_labels = ["__address__"]
		replacement   = "$1:10250"
		target_label  = "__address__"
	}

	// Set the metrics path to kubelet's cAdvisor endpoint
	rule {
		replacement  = "/metrics/cadvisor"
		target_label = "__metrics_path__"
	}

	// Set scheme to https (kubelet uses TLS)
	rule {
		replacement  = "https"
		target_label = "__scheme__"
	}

	// Add node label
	rule {
		source_labels = ["__meta_kubernetes_node_name"]
		target_label  = "node"
	}
}

// Scrape container metrics from kubelet
prometheus.scrape "cadvisor" {
	targets           = discovery.relabel.cadvisor.output
	job_name          = "cadvisor"
	scheme            = "https"
	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"

	tls_config {
		ca_file              = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
		insecure_skip_verify = false
	}

	forward_to = [prometheus.remote_write.default.receiver]
}

// ---------------------------------------------------------
// CONTAINER METRICS (discovery.kubelet)
// ---------------------------------------------------------

discovery.kubelet "local_pods" {
	bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
}

discovery.relabel "app_metrics" {
	targets = discovery.kubelet.local_pods.targets

	// Only scrape if the pod has annotation: prometheus.io/scrape: "true"
	rule {
		source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_scrape"]
		regex         = "true"
		action        = "keep"
	}

	// Set the path based on annotation (default /metrics)
	rule {
		source_labels = ["__meta_kubernetes_pod_annotation_prometheus_io_path"]
		regex         = "(.+)"
		target_label  = "__metrics_path__"
		action        = "replace"
	}

	// Use the declared port if specified in annotation
	rule {
		source_labels = ["__address__", "__meta_kubernetes_pod_annotation_prometheus_io_port"]
		regex         = "([^:]+)(?::\\d+)?;(\\d+)"
		replacement   = "$1:$2"
		target_label  = "__address__"
	}
}

prometheus.scrape "apps" {
	targets    = discovery.relabel.app_metrics.output
	forward_to = [prometheus.remote_write.default.receiver]
}

// ---------------------------------------------------------
// HOST/NODE METRICS
// ---------------------------------------------------------

prometheus.exporter.unix "host" {
	rootfs_path = "/host/root"
	procfs_path = "/host/proc"
	sysfs_path  = "/host/sys"

	// set_collectors = ["cpu", "diskstats", "filesystem", "loadavg", "meminfo", "netdev", "stat", "time", "uname"]
}

prometheus.scrape "node" {
	targets    = prometheus.exporter.unix.host.targets
	job_name   = "node"
	forward_to = [prometheus.remote_write.default.receiver]
}

// ---------------------------------------------------------
// REMOTE WRITE
// ---------------------------------------------------------

prometheus.remote_write "default" {
	endpoint {
		url = "http://prometheus-server.prometheus.svc.cluster.local:80/api/v1/write"
	}
}
